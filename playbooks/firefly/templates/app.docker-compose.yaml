services:
  firefly:
    container_name: {{ firefly_docker_name }}
    image: fireflyiii/core:latest
    volumes:
      - {{ debian_additional_disks["appdata"]["mount_point"] }}/firefly/uploads:/var/www/html/storage/upload
      - /usr/lib/locale/locale-archive:/usr/lib/locale/locale-archive:z
    env_file: {{ debian_additional_disks["appdata"]["mount_point"] }}/firefly/.env
    ports:
      - 8080:8080
    restart: unless-stopped
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy

  postgres:
    container_name: postgres
    image: postgres:18
    environment:
      POSTGRES_DB: firefly
      POSTGRES_USER: firefly
      POSTGRES_PASSWORD: {{ firefly_postgres_pass }}
    volumes:
      - {{ debian_additional_disks["postgres"]["mount_point"] }}/firefly/db:/var/lib/postgresql
    user: {{ nfs_user_id }}:{{ nfs_user_id }}
    restart: unless-stopped
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -h localhost -U $$POSTGRES_USER -d firefly"]
      interval: 2s
      timeout: 20s

  cron:
    #
    # To make this work, set STATIC_CRON_TOKEN in your .env file or as an environment variable and replace REPLACEME below
    # The STATIC_CRON_TOKEN must be *exactly* 32 characters long
    #
    image: alpine
    container_name: cron
    command: sh -c "echo \"0 3 * * * wget -qO- http://app:8080/api/v1/cron/{{ firefly_cron_token }}\" | crontab - && crond -f -L /dev/stdout"
    restart: unless-stopped

  redis:
    container_name: redis
    image: 'redis:alpine'
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 2s
    restart: unless-stopped
